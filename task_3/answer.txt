--------------------------------------------
task 3
1)
Код использует ifconfig для получения информации о сетевых интерфейсах.
Потом информация из ifconfig через конвейер передается grep, чтобы вытащить только строки, содержащие "TX packets"
Эти строки так же передаются через конвейер awk, чтобы получить в виде строк только 5-е столбы (в данном случае столбцы определяются по пробелам)
После вывод awk (5-й столбец,tx packets - это общий вес переданных пакетов по конкретному интерфейсу в байтах) записывается в файл

сначала запускается сценарий, описанный выше, вывод сохраняется в файл tmp1
затем ожидание 10 секунд, после - повторение сценария, но вывод сохраняется в tmp2

далее файлы объединяются с помощью paste построчно c разделителем в виде перевода строки, поэтому получается чередование:

1-я строка исходного файла - 1-я строка tmp1
2-я строка исходного файла - 1-я строка tmp2
3-я строка исходного файла - 2-я строка tmp1
4-я строка исходного файла - 2-я строка tmp2
...

помощью awk высчитывает разницу для всех четных и их предыдущих строк, после записывает в файл


фактически программа считает вес пакетов/10 за промежуток в 10 секунд для всех сетевых интерфейсов

2)

2.1) 
очевидный недостаток - сохранение временных данных в файлы tmp1, tmp2, а не в переменные.
за время в 10 секунд (даже меньшее очевидно) файлы могут быть изменены и т.п., к тому же они останутся после выполнения как мусор

2.2)
второй - не указано, по каким интерфейсам за 10 секунд прошли пакеты (их вес), то есть нельзя понять, что к чему относится

3)

Не удалось сократить код так, чтобы не сделать его еще сильно запутаннее, поэтому сделал функцию с говорящим именем и такую же переменную, пожертвовав размером кода.

intfs=$(/sbin/ifconfig | grep "mtu" | awk '{print $1}') && getTX() { /sbin/ifconfig | grep "TX packets" | awk '{print $5}'; } && tmp1=$(getTX) && sleep 10 && tmp2=$(getTX) && paste -d '\n' <(echo "$tmp1") <(echo "$tmp2") | awk 'NR%2==0{print ($1-p)/10.0}{p=$1}' | paste -d ' ' <(echo "$intfs") -



