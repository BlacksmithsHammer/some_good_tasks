Задание не доведено до полной готовности, не реализовано автоматическое тестирование. При этом значительная часть логики все же сделана.
-
В задании в исходной диаграмме было сказано о возможности реализовать с 0 задержкой, за счет протокола. При это была видна особенность на диаграмме в виде s_ready_o,
то есть модуль при постоянных валидных данных на запись имел задержку в обработке слов, что не очень приятно. Эту проблему я постарался решить, однако хоть какое-то адекватное 
тестирование проведено не было.

Для того, чтобы сохранять временные данные в буфер, создается набор регистров data, val_data_packets хранит в себе маску валидных слов в текущем буфере.
Чтобы правильно писать в буфер слов, нужно создать указатель - регистр cnt. Далее остается только комбинационная логика и DFF-регистры для вывода стробов валидности и конца пакета
в нужный момент - valid_d, last_d. 

Чтобы не было времени простоя при постоянных записи и чтении в upsizer'e, нужно перехватить момент, когда остается незаполненным 1 элемент в буфере слов либо когда подается строб
конца пакета. Для этого были созданы логические элементы empty_buff, wr_en, wr_event и send_event:
1) empty_buff в зависимости от текущих входных сигналов показывает, есть ли еше место в буфере или нет.
   Например, если остался 1 свободный элемент, то в зависимоcти от s_valid_i (есть ли прямо сейчас элемент на запись) значение будет различаться.
   То есть при наличии элемента на запись очевидно, что буфер будет полным, поэтому сигнал будет = 0, в противном случае = 1
2) wr_en и wr_event показывают, есть ли возможность писать сейчас и произойдет ли запись прямо сейчас.
3) send_event - немного недоработанная абстракция, указывает на то, будет ли отправка данных на выход через 1 такт или нет
В решении старался не использовать лишние регистры и логику.
Модуль идентичен указанному в задании графику входных взаимодействий за лишь тем исключением, что s_ready_o будет чаще = 1

Для запуска симуляции необходимо в modelsim запустить make_sim.do. Симуляция, к сожалению, только наглядная. При этом можно отправить новое слово или целый пакет с помощью тасков send_word и send_packet.
На вход send_packet принимает количество пакетов и значение сигнала last на последнем пакете. Полезная нагрузка пакетов генерируется атвоматически до 32 бит. 
