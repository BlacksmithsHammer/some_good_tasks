Код модуля fp32 был взят с репозитория https://github.com/dawsonjon/fpu/tree/master/adder
--------------------------------------------------------------------------------------
Сам модуль fp32 работает на основе fsm с 12 стадиями.
Для сложения 2-ух чисел (a + b = z) нужно дождаться строба на a-линии, отослать число, дождаться строба на b-линии и отослать b.

Ответ придёт вместе со стробом по z-линии. При этом нужно отправить ответ о получении числа, иначе fsm будет висеть на последней стадии ожидания, из-за чего не получится сложить следующие 2 числа. При этом сам модуль в целом защищен от неправильного взаимодействия по входам.

Для упрощения взаимодействия можно было бы объединить 1 и 2 стадии в модуле. Вместо этого написана обертка - /rtl/adder_example.sv, чтобы за 1 такт передать числа a и b. При этом ответ о получении все равно нужно будет загружать через обертку, мне показалось удобным, что модуль хранит результат до получения ответа бесконечно долго. 
Обертка принимает на вход a_i и b_i (2 числа), по команде на строб valid_stb_i числа начинают поочередно передаваться в модуль. Как только модуль закончит работу, в обертке появится строб valid_stb_o, который будет сигнализировать о результате в z_o. Чтобы привести модуль снова к работе, необходимо подать сигнал на ack_z_i. ack_z_i оповестит о готовности к работе модуля.

Автоматические тесты добавлены в виде функции new_test в файле adder_example_tb в папке tb, в которую поочередно вводятся числа a, b, и их ожидаемая сумма. При необходимости можно легко доработать тестбенч, чтобы в функцию new_test передавались значения из файла с помощью readmem. 
Для запуска тестов необходимо с помощью modelsim запустить файл make_sim.do.

Решить задачу о сложении N чисел я не успел, но и трактовка задания сильно влияет на само решение.
Чтобы сложение занимало минимальную площадь на кристалле, можно создать очередь (либо уже дан массив) и постепенно складывать все значения из нее. Это будет выгодно по площади, но по времени займет (N-1)*(13~14) тактов в худшем случае (fsm может гораздо раньше выдать ответ, например, при NaN, но максимальная длительность ожидания = 13-14)

Если нужна максимальная скорость сложения, то реализуется древовидная схема сложения: 1-ое число складывается со 2-ым, 3 с 4 и т.д. На следующий этап этого конвейера передаются уже N/2 результатов сложения, которые потом так же складываются между собой: сумма 1 и 2 чисел складывается с суммой 3 и 4 и т.д. В конце концов это займет Log2(N)*(13~14) циклов в худшем случае. Это решение конвейеризируемое и, соответственно, обладает высокой пропускной способностью вкупе с меньшей задержкой ожидания всей суммы. В качестве минуса можно выделить громадное потребление ресурсов на сумматоры: приблизительно 2N-1 сумматоров против 1 в первом решении.
